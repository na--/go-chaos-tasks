# Concurrent Filter Pipeline

Имате следния интерфейс:

```
type Task interface {
	Start() <-chan string
	SetConcurrency(limit uint8)
}
```

Той може да се имплементира от най-различни concurrent задачи. Всяка задача се стартира с извикването на `Start()` метода ѝ, а резултатите от задачата (под формата на `string`-ове) се подават асинхронно по върнатия от `Start()` канал. Когато дадена задача приключи, тя затваря собствения си канал. Чрез извикването на метода `SetConcurrency()` задаваме желаното от нас ниво на concurrency, с което задачата да се изпълнява. Той може да се извиква многократно преди или по време на изпълнението на задачата.


Имплементирайте функция `func NewFilterPipeline(tasks <-chan []Task, concurrencyLimit uint8, filter *regexp.Regexp) Task` със следните свойства:

* Приема канал за четене `tasks` на `Task` слайсове, първоначално ограничение за броя на едновременно изпълнявани задачи `concurrencyLimit` и регулярен израз `filter`.
* Връща написан от вас тип, който също имплементира `Task` интерфейса.
* При извикването на `Start()` веднага връща канал за резултатите си, а междувременно започва да прочита и изпълнява задачите от `tasks`.
* Всички задачи от всеки прочетен от `tasks` slice се изпълняват, но с максимално до `concurrencyLimit` задачи едновременно. Преминава се към задачите от следващ slice чак след като всички задачи от предишния са приключили.
* Получените от задачите в `tasks` резултати се проверяват за съответствие с подадения `filter` (използвайки `Regexp.MatchString()`). Ако отговарят, върнете ги като резултат и от вашия `Task`, в противен случай ги игнорирайте.
* Когато каналът `tasks` е затворен и всички задачи от последния slice са приключили и всички отговори върнати, вашата задача трябва да затвори резултатния си канал и да приключи своята работа.
